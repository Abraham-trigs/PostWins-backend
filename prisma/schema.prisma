// ============================================================
// schema.prisma
// ============================================================
// PostgreSQL Notes:
// - Enable pgcrypto for UUID generation:
//     CREATE EXTENSION IF NOT EXISTS pgcrypto;
// model Case         
// - Sensitive PII is isolated in BeneficiaryPII to support:
//     ‚Ä¢ Redaction
//     ‚Ä¢ Least privilege access
//     ‚Ä¢ Envelope encryption strategies
// ============================================================

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

////////////////////////////////////////////////////////////////
// ENUMS
////////////////////////////////////////////////////////////////

enum DisbursementType {
  PROVIDER_PAYMENT
  BENEFICIARY_PAYMENT
  VENDOR_PAYMENT
  REIMBURSEMENT
}

enum StakeholderRole {
  DONOR
  REGULATOR
  OPERATOR
  TECHNICAL
  OBSERVER
}

model ImpactMetric {
  id          String          @id @default(uuid())
  role        StakeholderRole
  metricName  String
  value       Float
  lastUpdated DateTime        @updatedAt
}

enum CaseStatus {
  INTAKED
  ROUTED
  ACCEPTED
  IN_REVIEW

  EXECUTING
  IN_DELIVERY
  VERIFIED
  FLAGGED

  COMPLETED
  REJECTED
  CANCELLED
  ARCHIVED
}

enum DisbursementStatus {
  AUTHORIZED
  EXECUTING
  EXECUTED
  COMPLETED
  FAILED
}

enum TaskId {
  START
  ENROLL
  ATTEND
  MODULE_1
  MODULE_2
}

enum ExecutionStatus {
  CREATED
  IN_PROGRESS
  BLOCKED
  COMPLETED
  ABORTED
}

enum OperationalMode {
  MOCK
  ASSISTED
  AI_AUGMENTED
}

enum ActorKind {
  HUMAN
  SYSTEM
}

enum AccessScope {
  PUBLIC
  PARTNER
  INTERNAL
}

enum CaseType {
  PROGRESS
  REQUEST
  EXECUTION
}

model Tag {
  id           String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  key          String   @unique
  label        String
  isRestricted Boolean  @default(false)
  createdAt    DateTime @default(now())

  cases CaseTag[]
}

model CaseTag {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  caseId    String   @db.Uuid
  tagId     String   @db.Uuid
  createdAt DateTime @default(now())

  case Case @relation(fields: [caseId], references: [id], onDelete: Cascade)
  tag  Tag  @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([caseId, tagId])
  @@index([tagId])
  @@index([caseId])
}

/// ‚ö†Ô∏è NON-AUTHORITATIVE STATUS
/// UI convenience only. Never infer lifecycle from this.
enum CaseLifecycle {
  INTAKE
  ROUTED
  ACCEPTED
  EXECUTING
  VERIFIED
  FLAGGED

  HUMAN_REVIEW

  COMPLETED
  REJECTED
  CANCELLED
  ARCHIVED
}

/// ‚ö†Ô∏è Decision snapshot metadata only.
enum RoutingOutcome {
  UNASSIGNED
  MATCHED
  FALLBACK
  BLOCKED
}

model PolicyEvaluation {
  id          String   @id @default(uuid())
  tenantId    String
  caseId      String
  policyKey   String
  version     String
  result      Json
  context     Json? // ‚Üê ADD THIS
  evaluatedAt DateTime @default(now())

  @@index([tenantId, caseId])
}

enum ApprovalStatus {
  APPROVED
  PENDING
  REJECTED
}

enum VerificationStatus {
  PENDING
  APPROVED
  REJECTED
}

enum VerificationDecision {
  APPROVED
  REJECTED
}

enum LedgerEventType {
  CASE_CREATED
  CASE_UPDATED
  LIFECYCLE_REPAIRED
  CASE_ACCEPTED
  CASE_FLAGGED
  CASE_ESCALATED
  CASE_REJECTED
  CASE_ARCHIVED
  CASE_CANCELLED

  ROUTED
  ROUTING_SUPERSEDED

  VERIFICATION_STARTED
  VERIFICATION_REQUESTED
  VERIFICATION_SUBMITTED
  VERIFIED
  VERIFICATION_REJECTED
  VERIFICATION_DISPUTED
  VERIFICATION_TIMED_OUT

  APPEAL_OPENED
  APPEAL_RESOLVED

  GRANT_CREATED
  GRANT_POLICY_APPLIED
  BUDGET_ALLOCATED
  TRANCHE_RELEASED
  BUDGET_SUPERSEDED
  TRANCHE_REVERSED

  EXECUTION_STARTED
  EXECUTION_PROGRESS_RECORDED
  EXECUTION_COMPLETED
  EXECUTION_ABORTED

  DISBURSEMENT_AUTHORIZED
  DISBURSEMENT_COMPLETED
  DISBURSEMENT_FAILED
  // VERIFICATION_REQUESTED
  //EVIDENCE_SUBMITTED
  //COUNTER_CLAIM_SUBMITTED
}

enum EvidenceKind {
  PHOTO
  VIDEO
  AUDIO
  DOCUMENT
  OTHER
}

enum AppealStatus {
  OPEN
  IN_REVIEW
  RESOLVED
  DISMISSED
}

enum DecisionType {
  ROUTING
  VERIFICATION
  FLAGGING
  APPEAL
  BUDGET
  TRANCHE
}

enum GrantStatus {
  DRAFT
  ACTIVE
  PAUSED
  CLOSED
}

enum TrancheStatus {
  PLANNED
  RELEASED
  REVERSED
}

////////////////////////////////////////////////////////////////
// CORE MULTI-TENANT ROOT
////////////////////////////////////////////////////////////////

model Tenant {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  slug      String   @unique
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Primary relations
  users         User[]
  orgs          Organization[]
  cases         Case[]
  grants        Grant[]
  ledgerCommits LedgerCommit[]
  auditEntries  AuditEntry[]

  // New relations
  executions       Execution[]
  approvalRequests ApprovalRequest[]
  decisions        Decision[]
  disbursements    Disbursement[]

  // Back relations
  roles                Role[]
  beneficiaries        Beneficiary[]
  messages             Message[]
  executionBodies      ExecutionBody[]
  executionBodyMembers ExecutionBodyMember[]
  verificationRecords  VerificationRecord[]
  verifications        Verification[]
  routingDecisions     RoutingDecision[]
  timelineEntries      TimelineEntry[]
  evidence             Evidence[]
  appeals              Appeal[]
  counterfactuals      CounterfactualRecord[]

  @@index([createdAt])
}

////////////////////////////////////////////////////////////////
// IDENTITY & ACCESS CONTROL
////////////////////////////////////////////////////////////////

model User {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId  String   @db.Uuid
  email     String
  name      String?
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  roles                    UserRole[]
  executionBodyMemberships ExecutionBodyMember[]
  sessions                 Session[]
  authoredCases            Case[]                @relation("CaseAuthor")
  messages                 Message[]
  verifications            Verification[]
  appealsOpened            Appeal[]              @relation("AppealOpenedBy")
  appealsReviewed          AppealDecision[]      @relation("AppealReviewedBy")

  auditEntries  AuditEntry[]
  ledgerCommits LedgerCommit[]

  caseAssignmentsAssigned CaseAssignment[]  @relation("CaseAssignmentAssignedBy")
  routingDecisionsDecided RoutingDecision[] @relation("RoutingDecisionDecidedBy")

  // New back-relations
  startedExecutions   Execution[]          @relation("ExecutionStarter")
  resolvedApprovals   ApprovalRequest[]
  decisions           Decision[]
  disbursements       Disbursement[]
  completedMilestones ExecutionMilestone[] @relation("MilestoneCompletedBy")

  @@unique([tenantId, email])
  @@index([tenantId, email])
  @@index([tenantId, createdAt])
}

model Session {
  id        String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId    String    @db.Uuid
  createdAt DateTime  @default(now())
  expiresAt DateTime
  revokedAt DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([expiresAt])
}

model ExecutionMilestone {
  id          String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  executionId String @db.Uuid

  label       String
  description String?

  /// Optional weight for weighted progress calculation
  weight Int @default(1)

  /// Completion tracking
  completedAt       DateTime?
  completedByUserId String?   @db.Uuid

  createdAt DateTime @default(now())

  execution   Execution @relation("ExecutionMilestones", fields: [executionId], references: [id], onDelete: Cascade)
  completedBy User?     @relation("MilestoneCompletedBy", fields: [completedByUserId], references: [id], onDelete: SetNull)

  /// Prevent duplicate milestone labels per execution
  @@unique([executionId, label])
  @@index([executionId])
  @@index([executionId, completedAt])
}

model Organization {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId  String   @db.Uuid
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  executionBody   ExecutionBody?
  donorGrants     Grant[]        @relation("GrantDonor")
  implementGrants Grant[]        @relation("GrantImplementer")

  @@index([tenantId, createdAt])
}

enum MessageType {
  DISCUSSION
  FOLLOW_UP
  VERIFICATION_REQUEST
  COUNTER_CLAIM
  EVIDENCE_SUBMISSION
}

model Message {
  id       String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId String @db.Uuid
  caseId   String @db.Uuid
  authorId String @db.Uuid

  parentId String?   @db.Uuid
  parent   Message?  @relation("Thread", fields: [parentId], references: [id])
  replies  Message[] @relation("Thread")

  clientMutationId String? @db.Uuid

  type MessageType
  body String?

  navigationContext Json?
  metadata          Json?

  isInternal Boolean  @default(false)
  createdAt  DateTime @default(now())

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  case   Case   @relation(fields: [caseId], references: [id], onDelete: Cascade)
  author User   @relation(fields: [authorId], references: [id], onDelete: Cascade)

  @@unique([tenantId, clientMutationId])

  // ‚ö° Cursor pagination index
  @@index([tenantId, caseId, createdAt(sort: Desc), id(sort: Desc)])
  @@index([tenantId, caseId, createdAt(sort: Desc)])
  @@index([parentId])
}

model MessageReceipt {
  id         String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId   String   @db.Uuid
  messageId  String   @db.Uuid
  userId     String   @db.Uuid

  deliveredAt DateTime?
  seenAt      DateTime?

  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  tenant  Tenant  @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId])
  @@index([userId])
  @@index([messageId])
}

model CaseReadPosition {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId  String   @db.Uuid
  caseId    String   @db.Uuid
  userId    String   @db.Uuid

  lastReadMessageId String  @db.Uuid
  lastReadAt        DateTime

  updatedAt         DateTime @updatedAt

  case   Case   @relation(fields: [caseId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([caseId, userId])
  @@index([tenantId, caseId, lastReadAt])
}
model Role {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId  String   @db.Uuid
  key       String
  name      String
  createdAt DateTime @default(now())

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  users       UserRole[]
  permissions RolePermission[]

  @@unique([tenantId, key])
  @@index([tenantId, key])
}

model Permission {
  id   String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  key  String @unique
  name String

  roles RolePermission[]
}

model UserRole {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId    String   @db.Uuid
  roleId    String   @db.Uuid
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  role Role @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@unique([userId, roleId])
  @@index([roleId])
}

model RolePermission {
  id           String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  roleId       String @db.Uuid
  permissionId String @db.Uuid

  role       Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  @@unique([roleId, permissionId])
  @@index([permissionId])
}

////////////////////////////////////////////////////////////////
// BENEFICIARY & PII SEGREGATION
////////////////////////////////////////////////////////////////

model Beneficiary {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId    String   @db.Uuid
  displayName String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  tenant Tenant          @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  pii    BeneficiaryPII?

  cases Case[] @relation("CaseBeneficiary")

  @@index([tenantId, createdAt])
}

/// Sensitive data isolated for least privilege access.
model BeneficiaryPII {
  id            String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  beneficiaryId String @unique @db.Uuid

  phone         String?
  nationalId    String?
  address       String?
  dateOfBirth   DateTime?
  encryptedBlob Bytes?

  beneficiary Beneficiary @relation(fields: [beneficiaryId], references: [id], onDelete: Cascade)

  @@index([phone])
  @@index([nationalId])
}

////////////////////////////////////////////////////////////////
// CASE DOMAIN
////////////////////////////////////////////////////////////////

/// ‚ö†Ô∏è LIFECYCLE LAW
/// Case.lifecycle MUST NOT be directly written.
/// All transitions must pass through:
///   transitionCaseLifecycleWithLedger

model Case {
  id            String  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId      String  @db.Uuid
  authorUserId  String  @db.Uuid
  beneficiaryId String? @db.Uuid
  referenceCode String  @unique

  mode  OperationalMode
  scope AccessScope
  type  CaseType

  tags CaseTag[]

  lifecycle CaseLifecycle @default(INTAKE)
  status    CaseStatus    @default(INTAKED)

  execution Execution?

  sdgGoal     String?
  summary     String?
  reasonCodes CaseReasonCode[]

  currentTask TaskId @default(START)

  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  archivedAt DateTime?

  tenant      Tenant       @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  author      User         @relation("CaseAuthor", fields: [authorUserId], references: [id], onDelete: Restrict)
  beneficiary Beneficiary? @relation("CaseBeneficiary", fields: [beneficiaryId], references: [id], onDelete: SetNull)

  // üîß Added missing opposite relations
  approvalRequests ApprovalRequest[]
  decisions        Decision[]
  disbursement     Disbursement?

  messages            Message[]
  verificationRecords VerificationRecord[]
  routingDecisions    RoutingDecision[]
  assignment          CaseAssignment?
  timelineEntries     TimelineEntry[]
  auditTrail          AuditEntry[]
  ledgerCommits       LedgerCommit[]
  appeals             Appeal[]
  counterfactuals     CounterfactualRecord[]
  grantLinks          GrantCase[]

  @@index([tenantId, createdAt(sort: Desc), id(sort: Desc)])
  @@index([tenantId, lifecycle, createdAt])
  @@index([tenantId, status, createdAt])
  @@index([tenantId, sdgGoal])
  @@index([authorUserId, createdAt])
  @@index([beneficiaryId, createdAt])
}

////////////////////////////////////////////////////////////////
// EXECUTION DOMAIN
////////////////////////////////////////////////////////////////

/// Represents the operational execution instance of a Case.
/// One-to-one with Case (enforced via unique caseId).
model Execution {
  id       String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId String @db.Uuid
  caseId   String @unique @db.Uuid

  status ExecutionStatus @default(CREATED)

  startedAt   DateTime?
  completedAt DateTime?
  abortedAt   DateTime?

  startedByUserId String? @db.Uuid

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  case   Case   @relation(fields: [caseId], references: [id], onDelete: Cascade)

  starter User? @relation("ExecutionStarter", fields: [startedByUserId], references: [id], onDelete: SetNull)

  progress ExecutionProgress[]

  /// Planned deliverables (used for calculated progress)
  milestones ExecutionMilestone[] @relation("ExecutionMilestones")

  @@index([tenantId, status])
  @@index([caseId])
}

/// Execution checkpoints / progress entries.
/// Append-only operational trail.
model ExecutionProgress {
  id          String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  executionId String @db.Uuid

  label      String
  detail     Json?
  recordedAt DateTime @default(now())

  execution Execution @relation(fields: [executionId], references: [id], onDelete: Cascade)

  @@index([executionId, recordedAt])
}

////////////////////////////////////////////////////////////////
// ROUTING & ASSIGNMENT
////////////////////////////////////////////////////////////////

/// Execution body (organization capable of delivering cases).
model ExecutionBody {
  id       String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId String @db.Uuid
  orgId    String @unique @db.Uuid

  capabilities Json
  isFallback   Boolean  @default(false)
  createdAt    DateTime @default(now())

  tenant Tenant       @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  org    Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  assignments      CaseAssignment[]
  routingDecisions RoutingDecision[]

  members ExecutionBodyMember[]

  @@index([tenantId, isFallback])
}

model ExecutionBodyMember {
  id              String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId        String   @db.Uuid
  executionBodyId String   @db.Uuid
  userId          String   @db.Uuid
  createdAt       DateTime @default(now())

  tenant        Tenant        @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  executionBody ExecutionBody @relation(fields: [executionBodyId], references: [id], onDelete: Cascade)
  user          User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([executionBodyId, userId])
  @@index([tenantId, executionBodyId])
  @@index([userId])
}

/// Single authoritative assignment per Case.
model CaseAssignment {
  id               String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  caseId           String   @unique @db.Uuid
  executionBodyId  String   @db.Uuid
  assignedAt       DateTime @default(now())
  assignedByUserId String?  @db.Uuid

  case          Case          @relation(fields: [caseId], references: [id], onDelete: Cascade)
  executionBody ExecutionBody @relation(fields: [executionBodyId], references: [id], onDelete: Restrict)
  assignedBy    User?         @relation("CaseAssignmentAssignedBy", fields: [assignedByUserId], references: [id], onDelete: SetNull)

  @@index([executionBodyId, assignedAt])
}

/// Snapshot of routing decision.
/// Does NOT represent lifecycle progression.
model RoutingDecision {
  id       String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId String @db.Uuid
  caseId   String @db.Uuid

  routingOutcome        RoutingOutcome
  chosenExecutionBodyId String?        @db.Uuid

  decidedAt       DateTime @default(now())
  decidedByUserId String?  @db.Uuid

  reasonCodes    RoutingReasonCode[]
  counterfactual CounterfactualRecord?

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  case   Case   @relation(fields: [caseId], references: [id], onDelete: Cascade)

  chosenExecutionBody ExecutionBody? @relation(fields: [chosenExecutionBodyId], references: [id], onDelete: SetNull)
  decidedBy           User?          @relation("RoutingDecisionDecidedBy", fields: [decidedByUserId], references: [id], onDelete: SetNull)

  @@index([caseId, decidedAt])
  @@index([tenantId, routingOutcome, decidedAt])
}

////////////////////////////////////////////////////////////////
// VERIFICATION DOMAIN
////////////////////////////////////////////////////////////////

/// Governs multi-verifier consensus workflow for a Case.
model VerificationRecord {
  id       String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId String @db.Uuid
  caseId   String @db.Uuid

  requiredVerifiers Int     @default(2)
  consensusReached  Boolean @default(false)

  routedAt   DateTime
  verifiedAt DateTime?
  createdAt  DateTime  @default(now())

  receivedVerifications Verification[]
  requiredRoles         VerificationRequiredRole[]

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  case   Case   @relation(fields: [caseId], references: [id], onDelete: Cascade)

  @@index([caseId])
  @@index([tenantId, consensusReached])
}

/// Required role-level policy for verification.
model VerificationRequiredRole {
  id                   String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  verificationRecordId String @db.Uuid
  roleKey              String

  verificationRecord VerificationRecord @relation(fields: [verificationRecordId], references: [id], onDelete: Cascade)

  @@unique([verificationRecordId, roleKey])
}

/// Individual verifier vote.
/// Prevents double voting via unique constraint.
model Verification {
  id                   String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId             String @db.Uuid
  verificationRecordId String @db.Uuid

  verifierUserId String             @db.Uuid
  status         VerificationStatus
  note           String?
  createdAt      DateTime           @default(now())

  conflictDisclosed Boolean @default(false)
  conflictNote      String?

  tenant             Tenant             @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  verificationRecord VerificationRecord @relation(fields: [verificationRecordId], references: [id], onDelete: Cascade)
  verifier           User               @relation(fields: [verifierUserId], references: [id], onDelete: Restrict)

  @@unique([verificationRecordId, verifierUserId])
  @@index([verifierUserId, createdAt])
}

////////////////////////////////////////////////////////////////
// GOVERNANCE & DECISIONS
////////////////////////////////////////////////////////////////

/// Policy approval workflow (structure preserved as-is).
model ApprovalRequest {
  id       String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId String @db.Uuid
  caseId   String @db.Uuid

  status ApprovalStatus

  policyKey String
  effect    Json
  reason    String

  resolvedAt       DateTime?
  resolvedByUserId String?   @db.Uuid

  resolutionNote String?

  createdAt DateTime @default(now())

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  case     Case   @relation(fields: [caseId], references: [id], onDelete: Cascade)
  resolver User?  @relation(fields: [resolvedByUserId], references: [id], onDelete: SetNull)

  @@index([tenantId, status, createdAt])
  @@index([caseId, status])
}

/// Generalized decision model with supersession support.
model Decision {
  id       String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId String @db.Uuid
  caseId   String @db.Uuid

  decisionType DecisionType
  actorKind    ActorKind
  actorUserId  String?      @db.Uuid

  reason        String?
  intentContext Json?
  decidedAt     DateTime @default(now())

  supersedesDecisionId String?   @unique @db.Uuid
  supersededAt         DateTime?

  case   Case   @relation(fields: [caseId], references: [id], onDelete: Cascade)
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  actor  User?  @relation(fields: [actorUserId], references: [id], onDelete: SetNull)

  supersedes   Decision? @relation("DecisionSupersession", fields: [supersedesDecisionId], references: [id], onDelete: Restrict)
  supersededBy Decision? @relation("DecisionSupersession")

  @@index([caseId, decidedAt])
  @@index([tenantId, decisionType, decidedAt])
}

////////////////////////////////////////////////////////////////
// LEDGER (EVENT SOURCED AUDIT)
////////////////////////////////////////////////////////////////

/// Append-only cryptographic commit log.
/// Multi-tenant exactly-once guarantee enforced.
model LedgerCommit {
  id       String  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId String  @db.Uuid
  caseId   String? @db.Uuid

  eventType LedgerEventType

  /// Database-sovereign logical clock.
  ts BigInt

  actorKind      ActorKind
  actorUserId    String?   @db.Uuid
  authorityProof String

  intentContext Json?

  /// Observability only ‚Äî NOT part of commitment hash.
  requestId String? @db.Uuid

  /// Canonical SHA-256 hash of normalized commit payload.
  commitmentHash String @unique

  /// Cryptographic signature over commitmentHash.
  signature String?

  payload Json

  supersedesCommitId String?       @unique @db.Uuid
  supersedes         LedgerCommit? @relation("LedgerSupersession", fields: [supersedesCommitId], references: [id], onDelete: Restrict)
  supersededBy       LedgerCommit? @relation("LedgerSupersession")

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  case   Case?  @relation(fields: [caseId], references: [id], onDelete: Cascade)
  actor  User?  @relation(fields: [actorUserId], references: [id], onDelete: SetNull)

  @@unique([ts])
  @@index([tenantId, ts])
  @@index([caseId, ts])
  @@index([eventType, ts])
  @@index([requestId])
}

////////////////////////////////////////////////////////////////
// TIMELINE & EVIDENCE
////////////////////////////////////////////////////////////////

/// Unified activity stream entry for a Case.
/// Supports system events, delivery notes, visits, and follow-ups.
model TimelineEntry {
  id       String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId String @db.Uuid
  caseId   String @db.Uuid

  // Examples: DELIVERY, FOLLOWUP, VISIT, NOTE
  type      String
  body      String?
  createdAt DateTime @default(now())

  evidence Evidence[]

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  case   Case   @relation(fields: [caseId], references: [id], onDelete: Cascade)

  @@index([caseId, createdAt])
}

/// Immutable evidence attachment.
/// Hash preserved even if storage object is later removed.
model Evidence {
  id              String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId        String @db.Uuid
  timelineEntryId String @db.Uuid

  kind       EvidenceKind
  storageKey String
  sha256     String
  mimeType   String?
  byteSize   Int?
  createdAt  DateTime     @default(now())

  tenant        Tenant        @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  timelineEntry TimelineEntry @relation(fields: [timelineEntryId], references: [id], onDelete: Cascade)

  @@index([timelineEntryId])
  @@index([sha256])
}

////////////////////////////////////////////////////////////////
// AUDIT TRAIL
////////////////////////////////////////////////////////////////

/// Human-readable audit trail (separate from cryptographic ledger).
model AuditEntry {
  id       String  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId String  @db.Uuid
  caseId   String? @db.Uuid

  actorLabel  String
  actorUserId String?  @db.Uuid
  note        String?
  createdAt   DateTime @default(now())

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  case   Case?  @relation(fields: [caseId], references: [id], onDelete: Cascade)
  actor  User?  @relation(fields: [actorUserId], references: [id], onDelete: SetNull)

  @@index([tenantId, createdAt])
  @@index([caseId, createdAt])
}

////////////////////////////////////////////////////////////////
// REASON CODES
////////////////////////////////////////////////////////////////

model CaseReasonCode {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  caseId    String   @db.Uuid
  code      String
  details   String?
  createdAt DateTime @default(now())

  case Case @relation(fields: [caseId], references: [id], onDelete: Cascade)

  @@index([caseId, createdAt])
  @@index([code])
}

model RoutingReasonCode {
  id                String  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  routingDecisionId String  @db.Uuid
  code              String
  details           String?

  routingDecision RoutingDecision @relation(fields: [routingDecisionId], references: [id], onDelete: Cascade)

  @@index([routingDecisionId])
  @@index([code])
}

////////////////////////////////////////////////////////////////
// APPEALS
////////////////////////////////////////////////////////////////

/// Appeal against case-related decision.
model Appeal {
  id             String  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId       String  @db.Uuid
  caseId         String  @db.Uuid
  openedByUserId String? @db.Uuid

  status     AppealStatus @default(OPEN)
  reason     String?
  createdAt  DateTime     @default(now())
  resolvedAt DateTime?

  decisions AppealDecision[]

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  case     Case   @relation(fields: [caseId], references: [id], onDelete: Cascade)
  openedBy User?  @relation("AppealOpenedBy", fields: [openedByUserId], references: [id], onDelete: SetNull)

  @@index([tenantId, status, createdAt])
  @@index([caseId, createdAt])
}

model AppealDecision {
  id             String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  appealId       String @db.Uuid
  reviewerUserId String @db.Uuid

  outcome   String
  rationale String?
  createdAt DateTime @default(now())

  appeal   Appeal @relation(fields: [appealId], references: [id], onDelete: Cascade)
  reviewer User   @relation("AppealReviewedBy", fields: [reviewerUserId], references: [id], onDelete: Restrict)

  @@index([appealId, createdAt])
  @@index([reviewerUserId, createdAt])
}

////////////////////////////////////////////////////////////////
// COUNTERFACTUAL RECORDS
////////////////////////////////////////////////////////////////

/// Deterministic explanation of decision alternatives.
/// Not AI-generated ‚Äî policy-driven.
model CounterfactualRecord {
  id                String  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId          String  @db.Uuid
  caseId            String  @db.Uuid
  routingDecisionId String? @unique @db.Uuid

  decisionType       DecisionType
  chosen             String
  constraintsApplied String[]
  alternatives       Json
  createdAt          DateTime     @default(now())

  tenant          Tenant           @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  case            Case             @relation(fields: [caseId], references: [id], onDelete: Cascade)
  routingDecision RoutingDecision? @relation(fields: [routingDecisionId], references: [id], onDelete: Cascade)

  @@index([caseId, createdAt])
  @@index([tenantId, decisionType, createdAt])
}

////////////////////////////////////////////////////////////////
// DISBURSEMENTS
////////////////////////////////////////////////////////////////

/// Financial execution tied to verification + execution provenance.
model Disbursement {
  id       String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId String @db.Uuid
  caseId   String @unique @db.Uuid

  type   DisbursementType
  status DisbursementStatus

  amount   Decimal @db.Decimal(18, 2)
  currency String

  payeeKind String
  payeeId   String

  actorKind      ActorKind
  actorUserId    String?   @db.Uuid
  authorityProof String

  verificationRecordId String @db.Uuid
  executionId          String @db.Uuid

  failureReason String?

  authorizedAt DateTime  @default(now())
  executedAt   DateTime?
  failedAt     DateTime?

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  case   Case   @relation(fields: [caseId], references: [id], onDelete: Cascade)
  actor  User?  @relation(fields: [actorUserId], references: [id], onDelete: SetNull)

  @@index([tenantId, status, authorizedAt])
  @@index([verificationRecordId])
  @@index([executionId])
}

////////////////////////////////////////////////////////////////
// GRANTS & BUDGETING
////////////////////////////////////////////////////////////////

model Grant {
  id       String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId String @db.Uuid

  donorOrgId       String @db.Uuid
  implementerOrgId String @db.Uuid

  status      GrantStatus @default(DRAFT)
  currency    String      @default("USD")
  totalAmount Decimal     @db.Decimal(18, 2)

  policyVersion String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  activatedAt   DateTime?
  closedAt      DateTime?

  caseLinks   GrantCase[]
  constraints GrantConstraint[]
  allocations BudgetAllocation[]
  tranches    Tranche[]

  tenant      Tenant       @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  donor       Organization @relation("GrantDonor", fields: [donorOrgId], references: [id], onDelete: Restrict)
  implementer Organization @relation("GrantImplementer", fields: [implementerOrgId], references: [id], onDelete: Restrict)

  @@index([tenantId, status, createdAt])
  @@index([donorOrgId, createdAt])
  @@index([implementerOrgId, createdAt])
}

model GrantCase {
  id      String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  grantId String @db.Uuid
  caseId  String @db.Uuid

  grant Grant @relation(fields: [grantId], references: [id], onDelete: Cascade)
  case  Case  @relation(fields: [caseId], references: [id], onDelete: Cascade)

  @@unique([grantId, caseId])
  @@index([caseId])
}

model GrantConstraint {
  id      String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  grantId String @db.Uuid

  kind      String
  rule      Json
  createdAt DateTime @default(now())

  grant Grant @relation(fields: [grantId], references: [id], onDelete: Cascade)

  @@index([grantId, createdAt])
  @@index([kind])
}

model BudgetAllocation {
  id      String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  grantId String @db.Uuid

  category  String
  amount    Decimal  @db.Decimal(18, 2)
  percent   Decimal? @db.Decimal(6, 3)
  createdAt DateTime @default(now())

  grant Grant @relation(fields: [grantId], references: [id], onDelete: Cascade)

  @@index([grantId, createdAt])
  @@index([category])
}

model Tranche {
  id      String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  grantId String @db.Uuid

  sequence       Int
  plannedPercent Decimal  @db.Decimal(6, 3)
  plannedAmount  Decimal? @db.Decimal(18, 2)

  status     TrancheStatus @default(PLANNED)
  releasedAt DateTime?
  reversedAt DateTime?

  releaseRule Json?
  events      TrancheEvent[]

  grant Grant @relation(fields: [grantId], references: [id], onDelete: Cascade)

  @@unique([grantId, sequence])
  @@index([grantId, status])
}

model TrancheEvent {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  trancheId String   @db.Uuid
  type      String
  payload   Json
  createdAt DateTime @default(now())

  tranche Tranche @relation(fields: [trancheId], references: [id], onDelete: Cascade)

  @@index([trancheId, createdAt])
}
