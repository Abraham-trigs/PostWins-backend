// schema.prisma
// Postgres notes:
// - enable pgcrypto for gen_random_uuid():  CREATE EXTENSION IF NOT EXISTS pgcrypto;
// - store sensitive PII separately (BeneficiaryPII) to support redaction + least privilege. :contentReference[oaicite:6]{index=6}

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum OperationalMode {
  MOCK
  ASSISTED
  AI_AUGMENTED
}

enum ActorKind {
  HUMAN
  SYSTEM
}

enum AccessScope {
  PUBLIC
  PARTNER
  INTERNAL
}

enum CaseType {
  PROGRESS
  REQUEST
  EXECUTION
}

enum CaseStatus {
  INTAKED
  IN_REVIEW
  VERIFIED
  FLAGGED
  ROUTED
  IN_DELIVERY
  COMPLETED
  REJECTED
  ARCHIVED
}

enum RoutingStatus {
  // Must match runtime: UNASSIGNED, MATCHED, FALLBACK, BLOCKED :contentReference[oaicite:7]{index=7}
  UNASSIGNED
  MATCHED
  FALLBACK
  BLOCKED
}

enum VerificationStatus {
  PENDING
  ACCEPTED
  REJECTED
}

enum LedgerEventType {
  CASE_CREATED
  CASE_UPDATED
  CASE_FLAGGED
  CASE_REJECTED
  CASE_ARCHIVED

  ROUTED
  ROUTING_SUPERSEDED

  VERIFICATION_SUBMITTED
  VERIFIED

  APPEAL_OPENED
  APPEAL_RESOLVED

  GRANT_CREATED
  GRANT_POLICY_APPLIED
  BUDGET_ALLOCATED
  TRANCHE_RELEASED
  BUDGET_SUPERSEDED
  TRANCHE_REVERSED
}

enum EvidenceKind {
  PHOTO
  VIDEO
  AUDIO
  DOCUMENT
  OTHER
}

enum AppealStatus {
  OPEN
  IN_REVIEW
  RESOLVED
  DISMISSED
}

enum DecisionType {
  ROUTING
  BUDGET
  TRANCHE
  FLAGGING
}

enum GrantStatus {
  DRAFT
  ACTIVE
  PAUSED
  CLOSED
}

enum TrancheStatus {
  PLANNED
  RELEASED
  REVERSED
}

model Tenant {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  slug      String   @unique
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  users         User[]
  orgs          Organization[]
  cases         Case[]
  grants        Grant[]
  ledgerCommits LedgerCommit[]
  auditEntries  AuditEntry[]

  @@index([createdAt])
}

model User {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId  String   @db.Uuid
  email     String
  name      String?
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  roles        UserRole[]
  sessions     Session[]
  authoredCases Case[] @relation("CaseAuthor")
  messages     Message[]
  verifications Verification[]
  appealsOpened Appeal[] @relation("AppealOpenedBy")
  appealsReviewed AppealDecision[] @relation("AppealReviewedBy")

  // actor traces for auditability-by-default :contentReference[oaicite:8]{index=8}
  auditEntries  AuditEntry[]
  ledgerCommits LedgerCommit[]

  @@unique([tenantId, email])
  @@index([tenantId, email])
  @@index([tenantId, createdAt])
}

model Session {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId    String   @db.Uuid
  createdAt DateTime @default(now())
  expiresAt DateTime
  revokedAt DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([expiresAt])
}

model Role {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId  String   @db.Uuid
  key       String
  name      String
  createdAt DateTime @default(now())

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  users       UserRole[]
  permissions RolePermission[]

  @@unique([tenantId, key])
  @@index([tenantId, key])
}

model Permission {
  id   String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  key  String @unique
  name String

  roles RolePermission[]
}

model UserRole {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId    String   @db.Uuid
  roleId    String   @db.Uuid
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  role Role @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@unique([userId, roleId])
  @@index([roleId])
}

model RolePermission {
  id           String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  roleId       String @db.Uuid
  permissionId String @db.Uuid

  role       Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  @@unique([roleId, permissionId])
  @@index([permissionId])
}

model Organization {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId  String   @db.Uuid
  name      String
  kind      String   // e.g. NGO, SCHOOL, DONOR, TRUSTEE, REGULATOR
  createdAt DateTime @default(now())

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  executionBody ExecutionBody?
  grantsAsDonor Grant[] @relation("GrantDonor")
  grantsAsImplementer Grant[] @relation("GrantImplementer")

  @@index([tenantId, kind])
  @@index([tenantId, name])
}

model Beneficiary {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId  String   @db.Uuid
  // public-ish profile (non-sensitive)
  displayName String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  pii    BeneficiaryPII?

  cases Case[] @relation("CaseBeneficiary")

  @@index([tenantId, createdAt])
}

model BeneficiaryPII {
  id            String  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  beneficiaryId String  @unique @db.Uuid

  phone         String?
  nationalId    String?
  address       String?
  dateOfBirth   DateTime?
  // store encrypted blobs if you’re doing app-level envelope encryption
  encryptedBlob Bytes?

  beneficiary Beneficiary @relation(fields: [beneficiaryId], references: [id], onDelete: Cascade)

  @@index([phone])
  @@index([nationalId])
}

model Case {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId  String   @db.Uuid

  // "author ≠ beneficiary" supported :contentReference[oaicite:9]{index=9}
  authorUserId String @db.Uuid
  beneficiaryId String? @db.Uuid

  mode   OperationalMode
  scope  AccessScope
  type   CaseType

  status        CaseStatus   @default(INTAKED)
  routingStatus RoutingStatus @default(UNASSIGNED)

  sdgGoal   String? // keep flexible; you can formalize to enum later
  summary   String?
  // deterministic, internal-only reasons for non-happy paths :contentReference[oaicite:10]{index=10}
  reasonCodes CaseReasonCode[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  archivedAt DateTime?

  tenant      Tenant      @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  author      User        @relation("CaseAuthor", fields: [authorUserId], references: [id], onDelete: Restrict)
  beneficiary Beneficiary? @relation("CaseBeneficiary", fields: [beneficiaryId], references: [id], onDelete: SetNull)

  messages          Message[]
  verificationRecords VerificationRecord[]
  routingDecisions  RoutingDecision[]
  assignment        CaseAssignment?
  timelineEntries   TimelineEntry[]
  auditTrail        AuditEntry[]
  ledgerCommits     LedgerCommit[]
  appeals           Appeal[]
  counterfactuals   CounterfactualRecord[]

  @@index([tenantId, createdAt])
  @@index([tenantId, status, createdAt])
  @@index([tenantId, routingStatus, createdAt])
  @@index([tenantId, sdgGoal])
  @@index([authorUserId, createdAt])
  @@index([beneficiaryId, createdAt])
}

model Message {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId  String   @db.Uuid
  caseId    String   @db.Uuid

  actorKind ActorKind
  userId    String?  @db.Uuid // null when system message
  body      String
  createdAt DateTime @default(now())

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  case   Case   @relation(fields: [caseId], references: [id], onDelete: Cascade)
  user   User?  @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([caseId, createdAt])
  @@index([tenantId, createdAt])
}

model ExecutionBody {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId  String   @db.Uuid
  orgId     String   @unique @db.Uuid

  // e.g. trust thresholds, coverage radius, sdg capabilities
  capabilities Json
  isFallback   Boolean @default(false) // "Khalistar as real execution body" :contentReference[oaicite:11]{index=11}
  createdAt DateTime @default(now())

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  org    Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  assignments CaseAssignment[]
  routingDecisions RoutingDecision[]

  @@index([tenantId, isFallback])
}

model CaseAssignment {
  id              String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  caseId          String   @unique @db.Uuid
  executionBodyId String   @db.Uuid
  assignedAt      DateTime @default(now())
  assignedByUserId String? @db.Uuid

  case          Case         @relation(fields: [caseId], references: [id], onDelete: Cascade)
  executionBody ExecutionBody @relation(fields: [executionBodyId], references: [id], onDelete: Restrict)
  assignedBy    User?        @relation(fields: [assignedByUserId], references: [id], onDelete: SetNull)

  @@index([executionBodyId, assignedAt])
}

model VerificationRecord {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId  String   @db.Uuid
  caseId    String   @db.Uuid

  // consensus target state :contentReference[oaicite:12]{index=12}
  sdgGoal           String
  requiredVerifiers Int      @default(2)
  consensusReached  Boolean  @default(false)

  routedAt   DateTime
  verifiedAt DateTime?

  receivedVerifications Verification[]
  requiredRoles VerificationRequiredRole[]

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  case   Case   @relation(fields: [caseId], references: [id], onDelete: Cascade)

  @@index([caseId, sdgGoal])
  @@index([tenantId, consensusReached])
  @@index([tenantId, routedAt])
}

model VerificationRequiredRole {
  id                  String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  verificationRecordId String @db.Uuid
  roleKey             String // e.g. "NGO_PARTNER", "STAFF", etc (store deterministic policy) :contentReference[oaicite:13]{index=13}

  verificationRecord VerificationRecord @relation(fields: [verificationRecordId], references: [id], onDelete: Cascade)

  @@unique([verificationRecordId, roleKey])
}

model Verification {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId  String   @db.Uuid
  verificationRecordId String @db.Uuid

  verifierUserId String @db.Uuid
  status         VerificationStatus
  note           String?
  createdAt      DateTime @default(now())

  // optional: conflict-of-interest disclosure hook :contentReference[oaicite:14]{index=14}
  conflictDisclosed Boolean @default(false)
  conflictNote      String?

  tenant             Tenant             @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  verificationRecord VerificationRecord @relation(fields: [verificationRecordId], references: [id], onDelete: Cascade)
  verifier           User               @relation(fields: [verifierUserId], references: [id], onDelete: Restrict)

  @@unique([verificationRecordId, verifierUserId]) // prevents double voting
  @@index([verifierUserId, createdAt])
}

model RoutingDecision {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId  String   @db.Uuid
  caseId    String   @db.Uuid

  chosenExecutionBodyId String? @db.Uuid
  routingStatus RoutingStatus
  decidedAt    DateTime @default(now())
  decidedByUserId String? @db.Uuid

  // deterministic explanation hooks
  reasonCodes RoutingReasonCode[]
  counterfactual CounterfactualRecord?

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  case   Case   @relation(fields: [caseId], references: [id], onDelete: Cascade)
  chosenExecutionBody ExecutionBody? @relation(fields: [chosenExecutionBodyId], references: [id], onDelete: SetNull)
  decidedBy User? @relation(fields: [decidedByUserId], references: [id], onDelete: SetNull)

  @@index([caseId, decidedAt])
  @@index([tenantId, routingStatus, decidedAt])
}

model TimelineEntry {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId  String   @db.Uuid
  caseId    String   @db.Uuid

  // matches the “unified stream” concept (messages + system events + timeline + governance) :contentReference[oaicite:15]{index=15}
  type      String   // e.g. "DELIVERY", "FOLLOWUP", "VISIT", "NOTE"
  body      String?
  createdAt DateTime @default(now())

  // evidence attachments
  evidence Evidence[]

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  case   Case   @relation(fields: [caseId], references: [id], onDelete: Cascade)

  @@index([caseId, createdAt])
}

model Evidence {
  id            String      @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId      String      @db.Uuid
  timelineEntryId String    @db.Uuid

  kind          EvidenceKind
  // store object storage pointers; keep hashes even if media deleted post-verification :contentReference[oaicite:16]{index=16}
  storageKey    String
  sha256        String
  mimeType      String?
  byteSize      Int?
  createdAt     DateTime @default(now())

  tenant       Tenant       @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  timelineEntry TimelineEntry @relation(fields: [timelineEntryId], references: [id], onDelete: Cascade)

  @@index([timelineEntryId])
  @@index([sha256])
}

model AuditEntry {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId  String   @db.Uuid
  caseId    String?  @db.Uuid

  // UI trail (human-readable) vs signed ledger (LedgerCommit) :contentReference[oaicite:17]{index=17}
  actorLabel String
  actorUserId String? @db.Uuid
  note      String?
  createdAt DateTime @default(now())

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  case   Case?  @relation(fields: [caseId], references: [id], onDelete: Cascade)
  actor  User?  @relation(fields: [actorUserId], references: [id], onDelete: SetNull)

  @@index([tenantId, createdAt])
  @@index([caseId, createdAt])
}

model LedgerCommit {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId  String   @db.Uuid
  caseId    String?  @db.Uuid

  eventType LedgerEventType
  ts        BigInt   // numeric timestamp (ms)
  actorKind ActorKind
  actorUserId String? @db.Uuid

  // non-repudiation shape (hash + signature) :contentReference[oaicite:18]{index=18}
  commitmentHash String
  signature      String?

  // append-only payload
  payload Json

  supersedesCommitId String? @db.Uuid
  supersededByCommitId String? @db.Uuid

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  case   Case?  @relation(fields: [caseId], references: [id], onDelete: Cascade)
  actor  User?  @relation(fields: [actorUserId], references: [id], onDelete: SetNull)

  supersedes   LedgerCommit? @relation("LedgerSupersession", fields: [supersedesCommitId], references: [id], onDelete: SetNull)
  supersededBy LedgerCommit? @relation("LedgerSupersession", fields: [supersededByCommitId], references: [id], onDelete: SetNull)

  @@index([tenantId, ts])
  @@index([caseId, ts])
  @@index([eventType, ts])
  @@index([commitmentHash])
}

model CaseReasonCode {
  id       String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  caseId   String @db.Uuid
  code     String
  details  String?
  createdAt DateTime @default(now())

  case Case @relation(fields: [caseId], references: [id], onDelete: Cascade)

  @@index([caseId, createdAt])
  @@index([code])
}

model RoutingReasonCode {
  id             String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  routingDecisionId String @db.Uuid
  code           String
  details        String?

  routingDecision RoutingDecision @relation(fields: [routingDecisionId], references: [id], onDelete: Cascade)

  @@index([routingDecisionId])
  @@index([code])
}

model Appeal {
  id        String      @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId  String      @db.Uuid
  caseId    String      @db.Uuid
  openedByUserId String? @db.Uuid

  status    AppealStatus @default(OPEN)
  reason    String?
  createdAt DateTime @default(now())
  resolvedAt DateTime?

  decisions AppealDecision[]

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  case   Case   @relation(fields: [caseId], references: [id], onDelete: Cascade)
  openedBy User? @relation("AppealOpenedBy", fields: [openedByUserId], references: [id], onDelete: SetNull)

  @@index([tenantId, status, createdAt])
  @@index([caseId, createdAt])
}

model AppealDecision {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  appealId  String   @db.Uuid
  reviewerUserId String @db.Uuid

  outcome   String   // e.g. "UPHOLD", "OVERTURN", "REQUEST_MORE_INFO"
  rationale String?
  createdAt DateTime @default(now())

  appeal   Appeal @relation(fields: [appealId], references: [id], onDelete: Cascade)
  reviewer User   @relation("AppealReviewedBy", fields: [reviewerUserId], references: [id], onDelete: Restrict)

  @@index([appealId, createdAt])
  @@index([reviewerUserId, createdAt])
}

model CounterfactualRecord {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId  String   @db.Uuid
  caseId    String   @db.Uuid
  routingDecisionId String? @unique @db.Uuid

  decisionType DecisionType
  chosen       String
  constraintsApplied String[]
  // alternatives (deterministic, not AI) :contentReference[oaicite:19]{index=19}
  alternatives Json
  createdAt DateTime @default(now())

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  case   Case   @relation(fields: [caseId], references: [id], onDelete: Cascade)
  routingDecision RoutingDecision? @relation(fields: [routingDecisionId], references: [id], onDelete: Cascade)

  @@index([caseId, createdAt])
  @@index([tenantId, decisionType, createdAt])
}

model Grant {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId  String   @db.Uuid

  donorOrgId       String @db.Uuid
  implementerOrgId String @db.Uuid

  status    GrantStatus @default(DRAFT)
  currency  String @default("USD")
  totalAmount Decimal @db.Decimal(18, 2)

  policyVersion String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  activatedAt DateTime?
  closedAt DateTime?

  // binding to cases/projects: keep flexible (many-to-many)
  caseLinks GrantCase[]

  constraints GrantConstraint[]
  allocations BudgetAllocation[]
  tranches    Tranche[]

  tenant      Tenant       @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  donor       Organization @relation("GrantDonor", fields: [donorOrgId], references: [id], onDelete: Restrict)
  implementer Organization @relation("GrantImplementer", fields: [implementerOrgId], references: [id], onDelete: Restrict)

  @@index([tenantId, status, createdAt])
  @@index([donorOrgId, createdAt])
  @@index([implementerOrgId, createdAt])
}

model GrantCase {
  id      String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  grantId String @db.Uuid
  caseId  String @db.Uuid

  grant Grant @relation(fields: [grantId], references: [id], onDelete: Cascade)
  case  Case  @relation(fields: [caseId], references: [id], onDelete: Cascade)

  @@unique([grantId, caseId])
  @@index([caseId])
}

model GrantConstraint {
  id        String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  grantId   String @db.Uuid

  // store donor structured rules (earmarks/caps/floors/allow-deny/tranche rules)
  kind      String
  rule      Json
  createdAt DateTime @default(now())

  grant Grant @relation(fields: [grantId], references: [id], onDelete: Cascade)

  @@index([grantId, createdAt])
  @@index([kind])
}

model BudgetAllocation {
  id        String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  grantId   String @db.Uuid

  category  String
  amount    Decimal @db.Decimal(18, 2)
  percent   Decimal? @db.Decimal(6, 3)
  createdAt DateTime @default(now())

  grant Grant @relation(fields: [grantId], references: [id], onDelete: Cascade)

  @@index([grantId, createdAt])
  @@index([category])
}

model Tranche {
  id        String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  grantId   String @db.Uuid

  sequence  Int
  plannedPercent Decimal @db.Decimal(6, 3)
  plannedAmount  Decimal? @db.Decimal(18, 2)

  status    TrancheStatus @default(PLANNED)
  releasedAt DateTime?
  reversedAt DateTime?

  // event-based conditions stored deterministically
  releaseRule Json?
  events      TrancheEvent[]

  grant Grant @relation(fields: [grantId], references: [id], onDelete: Cascade)

  @@unique([grantId, sequence])
  @@index([grantId, status])
}

model TrancheEvent {
  id        String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  trancheId String @db.Uuid
  type      String
  payload   Json
  createdAt DateTime @default(now())

  tranche Tranche @relation(fields: [trancheId], references: [id], onDelete: Cascade)

  @@index([trancheId, createdAt])
}
